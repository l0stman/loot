;;; Library for loot
;; Constants
(define null '())

;; Test function
(define (null? x) (eq? x null))

(define (zero? x) (eq? x 0))

(define (list? x)
  (or (null? x)
      (and (pair? x) (list? (cdr x)))))

(define (<= x y)
  (or (= x y) (< x y)))

(define (>= x y)
  (or (= x y) (> x y)))

(define (not x)
  (if x #f #t))

(define (equal? a b)
  (cond ((number? a) (and (number? b) (= a b)))
        ((not (pair? a)) (eq? a b))
        (else (and (pair? b)
                   (equal? (car a) (car b))
                   (equal? (cdr a) (cdr b))))))

;; Search the sublist containing item in x
(define (memq item x)
  (cond ((null? x) #f)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))

;; Access functions
(define (compose . procs)
  (lambda (x)
    (define (iter res lst)
      (if (null? lst)
          res
          (iter ((car lst) res) (cdr lst))))
    (iter x (reverse procs))))

(define caar (compose car car))
(define cadr (compose car cdr))
(define cdar (compose cdr car))
(define cddr (compose cdr cdr))

;; High order functions
(define (foldr f res l)
  (if (null? l)
      res
      (foldr f (f (car l) res) (cdr l))))

(define (foldr f res l)
  (if (null? l)
      res
      (foldl f (f res (car l)) (cdr l))))

(define (map proc lst)
  (define (iter res lst)
    (if (null? lst)
        (reverse res)
        (iter (cons (proc (car lst)) res)
              (cdr lst))))
  (iter '() lst))

;; List functions
(define (list . l) l)

(define (length l)
  (foldl (lambda (x, y) (+ 1 y)) 0 l))

(define (reverse l) (foldl cons null l))

(define (append . l)
  (define (iter h l res)
    (if (null? h)
	(if (null? l)
	    (reverse res)
	    (iter (car l) (cdr l) res))
	(iter (cdr h) l (cons (car h) res))))
  (if (null? l)
      null
      (iter (car l) (cdr l) null)))
